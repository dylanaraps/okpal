#!/bin/sh -e

die() {
    printf '%s\n' "${1:-Usage: ${0##*/}: [-v] img img img}" >&6
    exit 1
}

hex2rgb() {
    set -- "${1##\#}"

    # Ensure that we're dealing with hex that is
    # six characters in length.
    case ${#1}$1 in 6*[G-Zg-z]*) 
        die "Invalid hex input"
    esac

    # Split the string into three portions in a
    # really lazy way..
    r=${1%%????}
    g=${1##??}
    g=${g%%??}
    b=${1##????}

    # This is quite possibly _not_ POSIX shell.
    # This can also cause the shell to crash when
    # fed invalid input.
    r=$((0x$r))
    g=$((0x$g))
    b=$((0x$b))
}

mod() {
    # This function naively messes around with
    # (hex) colors.
    hex2rgb "$2"

    # The operator is stored in a variable
    # which makes shellcheck freak out.
    # shellcheck disable=1102,2086
    {
        r=$((r $3 $4))
        g=$((g $3 $4))
        b=$((b $3 $4))
    }

    # Ensure that all input is within the range of
    # 0-255 and correct any issues.
    r=$((r > 255 ? 255 : r < 0 ? 0 : r))
    g=$((g > 255 ? 255 : g < 0 ? 0 : g))
    b=$((b > 255 ? 255 : b < 0 ? 0 : b))

    # Abuse export to dynamically name and declare
    # variables. This also makes it global.
    export "$1=$(printf '%02x%02x%02x' "$r" "$g" "$b")"
}

img() {
    # Grab a random 3 digit number from /dev/urandom
    # and use it to select a random image from the
    # list given as input.
    #
    # This still works when there is only a single 
    # image passed on the command-line.
    shift "$(($(
        tr -dc 1-9 < /dev/urandom |
        dd ibs=1 obs=1 count=3
    ) % $#))" 

    img=$1
}

wal() {
    # Set the wallpaper by running each one. If the
    # exit status is '127' (command not found),
    # we die. If the command succeeds, we return.
           feh --bg-fill              "$img" ||
    xwallpaper --zoom                 "$img" ||
      nitrogen --set-zoom-fill        "$img" ||
           bgs -z                     "$img" ||
      hsetroot -fill                  "$img" ||
         habak -mS                    "$img" ||
       display -backdrop -window root "$img" ||

    [ $? != 127 ] || die "Failed to set the wallpaper"
}

col() {
    # Run imagemagick to generate the palette and store
    # the result in a temporary file. We'll then later
    # read from this file to operate on the information.
    #
    # This is a lot easier than trying to pass around
    # strings with a separator and splitting endlessly.
    "$magick" "$img" \
        -resize 512x \
        -alpha  off \
        -fill   white \
        -posterize 6 \
        -colors 16 \
        -unique-colors \
        txt:- \
    > "$cac/c$$"
}

pal() {
    # Convert the colors extracted from the image into
    # a usable terminal color palette.
    #
    # Read the raw imagemagick output, split on ' #'
    # and add every 3rd item of each line to the
    # argument list.
    while IFS=" #" read -r _ _ col _; do j=$((j + 1))
        [ "$j" -lt 10 ] && continue
        [ "$j" -gt 16 ] && break

        set -- "$@" "$col"
    done < "$cac/c$$"

    # Imagemagick adds a header line to the output.
    shift

    # These variables are dynamically defined,
    # ignore undeclared variable warnings.
    # shellcheck disable=2154
    {
        mod bg "$2"  / 4
        mod fg "$2"  + 150
        mod co "$bg" + 90

        set -- "$bg" "$@" "$fg" "$co" "$@" "$fg"
    }

    printf '%s\n' "$@" > "$cac/c$$"
}

seq() {
    # Convert the list of colors into a series of
    # escape sequences which will then be applied
    # to each terminal.
    seq_add() { seqs="$seqs]$1;#$2\\"; }

    while read -r line; do 
        seq_add "4;${k:-0}" "$line"

        case $k in
            0) seq_add 11 "$line" 
               
               [ "$VTE_VERSION" ] || 
                   seq_add 708 "$line"
            ;;

           15) seq_add 10 "$line" 
               seq_add 12 "$line"
        esac

        k=$((k + 1))
    done < "$cac/c$$"

    # Send the sequence list to every terminal device
    # we have write permissions to.
    for tty in /dev/fd/0 /dev/pts/[0-9]*; do 
        [ ! -w "$tty" ] || printf %b "$seqs" > "$tty" &
    done
}

art() {
    # Construst a palette of the generated colorscheme
    # so the user can see what it looks like straight away.
    for i in 1 2 3 4 5 6 7; do
        printf '\033[4%sm   \033[m' "$i" >&6
    done

    printf '\n' >&6
}

main() {
    # Speed things up by disabling the use of unicode
    # and sticking to the C locale..
    export LC_ALL=C 

    # Hide stdout/stderr by default to allow for selective
    # and controlled printing to the two.
    exec 2>/dev/null 6>&1 >/dev/null

    # Create the cache directory which will store the
    # palettes and other needed data.
    mkdir -p "${cac:=${XDG_CACHE_HOME:=$HOME/.cache}/${0##*/}}"

    # Figure out what imagemagick is called.
    magick=$(command -v convert || command -v magick) ||
        die "Imagemagick not installed"

    # Parse the options "inline" instead of via a function
    # so that we can mofigy the script's global argument list.
    while getopts vV opt; do case $opt in 
        v) exec 2>&6 ;;
        V) die "0.0.1" ;;
        ?) die ;;
    esac; done

    # Argument parsing is done, shift what we've parsed to
    # leave the list of images.
    shift "$((OPTIND - 1))"

    # There's no image to operate on.
    [ "$1" ] || die

    # Do all file checks here so that we can carry on
    # blindly later.
    for file do [ -f "$file" ] || 
        die "File '$file' doesn't exist"
    done

    img "$@"; wal "$img"; col "$img"; pal; seq; art; art
}

main "$@"
